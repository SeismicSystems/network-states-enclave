// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {IncrementalMerkleTree} from "./IncrementalMerkleTree.sol";

/*
 * Interface for the solidity verifier generated by snarkjs
 */
interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[11] memory input
    ) external view returns (bool);
}

/*
 * Interface for poseidon hasher where t = 3.
 */
interface IHasherT3 {
    function poseidon(uint256[2] memory input) external pure returns (uint256);
}

contract NStates is IncrementalMerkleTree {
    IHasherT3 hasherT3 = IHasherT3(0x5FbDB2315678afecb367f032d93F642f64180aa3);
    IVerifier verifierContract;

    event NewLeaf(uint256 h);
    event NewNullifier(uint256 nf);

    address public owner;
    mapping(uint256 => bool) public nullifiers;

    constructor(
        uint8 treeDepth,
        uint256 nothingUpMySleeve,
        address verifier
    ) IncrementalMerkleTree(treeDepth, nothingUpMySleeve) {
        verifierContract = IVerifier(verifier);
        owner = msg.sender;
    }

    /*
     * Functions with this modifier attached can only be called by the contract
     * deployer.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    /*
     * Game deployer has the ability to add initial states (leaves) during board
     * initialization.
     */
    function set(uint256 h) public onlyOwner {
        emit NewLeaf(h);
        insertLeaf(h);
    }

    /*
     * Accepts new states for tiles involved in move. Nullifies old states.
     */
    function move(
        uint256 uFrom,
        uint256 uTo,
        uint256 nfFrom,
        uint256 nfTo
    ) public {
        emit NewLeaf(uFrom);
        emit NewLeaf(uTo);
        emit NewNullifier(nfFrom);
        emit NewNullifier(nfTo);

        nullifiers[nfFrom] = true;
        nullifiers[nfTo] = true;

        insertLeaf(uFrom);
        insertLeaf(uTo);
    }

    /* 
     * Number of leaves in the merkle tree. Value is roughly double the number 
     * of historic accepted moves. 
     */
    function getNumLeaves() public view returns (uint256) {
        return nextLeafIndex;
    }

    /*
     * Compute poseidon hash of two child hashes. 
     */
    function _hashLeftRight(
        uint256 l,
        uint256 r
    ) internal view override returns (uint256) {
        return hasherT3.poseidon([l, r]);
    }
}
