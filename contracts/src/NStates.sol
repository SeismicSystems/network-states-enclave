// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/*
 * Interface for the solidity verifier generated by snarkjs
 */
interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[17] memory input
    ) external view returns (bool);
}

struct MoveInputs {
    uint256 currentWaterInterval;
    uint256 fromPkHash;
    uint256 fromCityId;
    uint256 toCityId;
    uint256 ontoSelfOrUnowned;
    uint256 numTroopsMoved;
    uint256 enemyLoss;
    uint256 fromIsCityTile;
    uint256 toIsCityTile;
    uint256 takingCity;
    uint256 takingCapital;
    uint256 fromCityTroops;
    uint256 toCityTroops;
    uint256 hTFrom;
    uint256 hTTo;
    uint256 hUFrom;
    uint256 hUTo;
}

struct Groth16Proof {
    uint256[2] a;
    uint256[2][2] b;
    uint256[2] c;
}

struct Signature {
    uint8 v;
    bytes32 r;
    bytes32 s;
    uint256 b;
}

contract NStates {
    IVerifier verifierContract =
        IVerifier(0x5FbDB2315678afecb367f032d93F642f64180aa3);

    event NewMove(uint256 hUFrom, uint256 hUTo);

    address public owner;
    uint256 public numBlocksInInterval;
    uint256 public numStartingResources;
    uint256 public claimedMoveLifeSpan;

    mapping(uint256 => uint256) public citiesToPlayer;
    mapping(uint256 => uint256[]) public playerToCities;
    mapping(uint256 => uint256) public playerToCapital;
    mapping(uint256 => uint256) public capitalToPlayer;

    // A city's index in player's list of cities. Maintained for O(1) deletion
    mapping(uint256 => uint256) public indexOfCity;

    mapping(uint256 => uint256) public cityArea;
    mapping(uint256 => uint256) public cityResources;

    mapping(uint256 => uint256) public cityTileResources;
    mapping(uint256 => uint256) public playerLatestUpdateBlock;

    mapping(uint256 => bool) public tileCommitments;

    constructor(
        address _owner,
        uint256 _numBlocksInInterval,
        uint256 _numStartingResources,
        uint256 _claimedMoveLifeSpan
    ) {
        owner = _owner;
        numBlocksInInterval = _numBlocksInInterval;
        numStartingResources = _numStartingResources;
        claimedMoveLifeSpan = _claimedMoveLifeSpan;
    }

    /*
     * Functions with this modifier attached can only be called by the contract
     * deployer.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    /*
     * Game deployer has the ability to add initial states (leaves) during board
     * initialization.
     */
    function set(uint256 h) public onlyOwner {
        tileCommitments[h] = true;
    }

    /*
     * Game deployer has the ability to initialize players onto the board.
     */
    function spawn(uint256 pkHash, uint256 cityId, uint256 h) public onlyOwner {
        require(cityId != 0, "City ID must be a non-zero value");
        require(citiesToPlayer[cityId] == 0, "City is already in game");

        set(h);

        playerToCapital[pkHash] = cityId;
        capitalToPlayer[cityId] = pkHash;

        citiesToPlayer[cityId] = pkHash;
        playerToCities[pkHash] = [cityId];
        indexOfCity[cityId] = 0;

        cityArea[cityId] = 1;
        cityResources[cityId] = numStartingResources;

        cityTileResources[cityId] = numStartingResources;
        playerLatestUpdateBlock[pkHash] = block.number;
    }

    /*
     * Accepts new states for tiles involved in move. Moves must operate on
     * states whose commitments are on-chain, AND carry a ZKP anchored to a
     * commited state, AND carry a signature from the enclave.
     */
    function move(
        MoveInputs memory moveInputs,
        Groth16Proof memory moveProof,
        Signature memory sig
    ) public {
        require(
            tileCommitments[moveInputs.hTFrom] &&
                tileCommitments[moveInputs.hTTo],
            "Old tile states must be valid"
        );
        require(
            block.number <= sig.b + claimedMoveLifeSpan,
            "This move is expired, please submit a new move"
        );
        require(
            currentWaterInterval() >= moveInputs.currentWaterInterval,
            "Move is too far into the future, change currentWaterInterval value"
        );
        require(
            moveInputs.fromPkHash == citiesToPlayer[moveInputs.fromCityId],
            "Must move from a city that you own"
        );
        require(
            checkOntoSelfOrUnowned(moveInputs),
            "Value of ontoSelfOrUnowned is incorrect"
        );
        require(
            checkCityTroops(moveInputs),
            "Value of fromCityTroops or toCityTroops is incorrect"
        );
        require(
            getSigner(moveInputs.hUFrom, moveInputs.hUTo, sig) == owner,
            "Enclave signature is incorrect"
        );
        require(
            verifierContract.verifyProof(
                moveProof.a,
                moveProof.b,
                moveProof.c,
                toArray(moveInputs)
            ),
            "Invalid move proof"
        );

        delete tileCommitments[moveInputs.hTFrom];
        delete tileCommitments[moveInputs.hTTo];

        tileCommitments[moveInputs.hUFrom] = true;
        tileCommitments[moveInputs.hUTo] = true;

        updateCityResources(moveInputs);

        if (moveInputs.takingCity == 1) {
            transferCityOwnership(
                moveInputs.fromPkHash,
                moveInputs.toCityId,
                moveInputs.ontoSelfOrUnowned
            );
        } else if (moveInputs.takingCapital == 1) {
            uint256 enemy = citiesToPlayer[moveInputs.toCityId];
            while (playerToCities[enemy].length > 0) {
                transferCityOwnership(
                    moveInputs.fromPkHash,
                    moveInputs.toCityId,
                    0
                );
            }
            delete playerToCities[enemy];
            delete playerToCapital[enemy];
        }

        emit NewMove(moveInputs.hUFrom, moveInputs.hUTo);
    }

    /*
     * Helper function for move(). Checks if public signal ontoSelfOrUnowned is
     * set correctly. ontoSelfOrUnowned is used in the ZKP, but must be
     * checked onchain.
     */
    function checkOntoSelfOrUnowned(
        MoveInputs memory mv
    ) internal view returns (bool) {
        uint256 toCityOwner = citiesToPlayer[mv.toCityId];
        if (toCityOwner == mv.fromPkHash || toCityOwner == 0) {
            return mv.ontoSelfOrUnowned == 1;
        }
        return mv.ontoSelfOrUnowned == 0;
    }

    function checkCityTroops(
        MoveInputs memory mv
    ) internal view returns (bool) {
        bool fromCorrect = true;
        bool toCorrect = true;
        if (
            mv.fromIsCityTile == 1 &&
            mv.fromCityTroops != cityTileResources[mv.fromCityId]
        ) {
            fromCorrect = false;
        }
        if (
            mv.toIsCityTile == 1 &&
            mv.toCityTroops != cityTileResources[mv.toCityId]
        ) {
            toCorrect = false;
        }
        return fromCorrect && toCorrect;
    }

    /*
     * Helper function for move(). Updates city resource values onchain based on
     * resource management logic.
     *
     * [TODO]: Currently cityTileResources[cityId] = cityResources[cityId]
     * always. Proper city troop updates increments cityTileResources on every
     * move.
     */
    function updateCityResources(MoveInputs memory mv) internal {
        // cityResources[fromCityId]
        if (
            mv.takingCity == 1 ||
            mv.takingCapital == 1 ||
            (mv.ontoSelfOrUnowned == 1 && mv.toCityId != 0)
        ) {
            // Taking city/capital, or moving onto self-owned tile
            decrementCityResources(
                mv.fromCityId,
                mv.numTroopsMoved,
                mv.fromIsCityTile
            );
        } else if (mv.ontoSelfOrUnowned == 0) {
            // Capturing enemy non-city tile or attacking enemy
            decrementCityResources(
                mv.fromCityId,
                mv.enemyLoss,
                mv.fromIsCityTile
            );
        } else if (mv.fromIsCityTile == 1) {
            // Moving onto unowned tile
            cityTileResources[mv.fromCityId] -= mv.numTroopsMoved;
        }

        // cityResources[toCityId]
        if (mv.ontoSelfOrUnowned == 1 && mv.toCityId != 0) {
            // Moving onto self-owned tile
            incrementCityResources(
                mv.toCityId,
                mv.numTroopsMoved,
                mv.toIsCityTile
            );
        } else if (mv.takingCity == 1 || mv.takingCapital == 1) {
            // Taking enemy city/capital
            incrementCityResources(
                mv.toCityId,
                mv.numTroopsMoved - mv.enemyLoss,
                mv.toIsCityTile
            );
        } else if (mv.ontoSelfOrUnowned == 0) {
            // Capturing enemy non-city tile or attacking enemy
            decrementCityResources(mv.toCityId, mv.enemyLoss, mv.toIsCityTile);
        }

        // cityArea[fromCityId] and cityArea[toCityId]
        if (
            mv.ontoSelfOrUnowned == 0 &&
            mv.takingCity == 0 &&
            mv.takingCapital == 0
        ) {
            cityArea[mv.fromCityId]++;
            cityArea[mv.toCityId]--;
        } else if (mv.toCityId == 0) {
            cityArea[mv.fromCityId]++;
        }

        // Troop updates for all players' cities
        troopUpdate(citiesToPlayer[mv.fromCityId]);
        if (mv.toCityId != 0) {
            troopUpdate(citiesToPlayer[mv.toCityId]);
        }
    }

    /*
     * Adds troops to a city's resource count. If moving onto the actual city
     * tile, then increment the tile resource count as well.
     */
    function incrementCityResources(
        uint256 cityId,
        uint256 dTroops,
        uint256 isCityTile
    ) internal {
        cityResources[cityId] += dTroops;
        if (isCityTile == 1) {
            cityTileResources[cityId] += dTroops;
        }
    }

    /*
     * Serves same purpose as incrementCityResources, except for subtracting
     * troops.
     */
    function decrementCityResources(
        uint256 cityId,
        uint256 dTroops,
        uint256 isCityTile
    ) internal {
        cityResources[cityId] -= dTroops;
        if (isCityTile == 1) {
            cityTileResources[cityId] -= dTroops;
        }
    }

    /*
     * Cities troop update. On each move, all of both players' cities are given
     * troop updates accordingly.
     *
     * [TODO]: use the correct formula instead of a temporary one.
     */
    function troopUpdate(uint256 pkHash) internal {
        uint256[] memory cities = playerToCities[pkHash];
        uint256 numCities = cities.length;
        uint256 totalArea = 0;
        uint256 totalResources = 0;

        for (uint256 i = 0; i < numCities; i++) {
            totalArea += cityArea[cities[i]];
            totalResources += cityResources[cities[i]];
        }
        // [TMP]
        uint256 inc = ((block.number - playerLatestUpdateBlock[pkHash]) *
            totalArea *
            totalResources) / numCities;
        // [TMP]
        inc = 0;
        for (uint256 i = 0; i < numCities; i++) {
            incrementCityResources(cities[i], inc, 1);
        }
        playerLatestUpdateBlock[pkHash] = block.number;
    }

    /*
     * Transfers ownership of one city to its new owner.
     */
    function transferCityOwnership(
        uint256 newOwner,
        uint256 toCityId,
        uint256 ontoSelfOrUnowned
    ) internal {
        // If player is moving onto an enemy's city
        if (ontoSelfOrUnowned == 0) {
            uint256 enemy = citiesToPlayer[toCityId];

            // Pop toCityId from enemyCityList
            uint256 lastIndex = playerToCities[enemy].length - 1;
            uint256 lastElement = playerToCities[enemy][lastIndex];
            playerToCities[enemy][indexOfCity[toCityId]] = lastElement;
            playerToCities[enemy].pop();

            // The new index of lastElement is where toCityId was
            indexOfCity[lastElement] = indexOfCity[toCityId];
        }

        uint256[] storage cityList = playerToCities[newOwner];
        indexOfCity[toCityId] = cityList.length;
        cityList.push(toCityId);
        playerToCities[newOwner] = cityList;
        citiesToPlayer[toCityId] = newOwner;
    }

    /*
     * Troop/water updates are counted in intervals, where the current interval is
     * the current block height divided by interval length.
     */
    function currentWaterInterval() public view returns (uint256) {
        return block.number / numBlocksInInterval;
    }

    /*
     * Getter for cityTileResources. Used by client to set fromCityTroops and
     * toCityTroops.
     */
    function getCityTileResources(
        uint256 cityId
    ) public view returns (uint256) {
        return cityTileResources[cityId];
    }

    /*
     * From a signature obtain the address that signed. This should
     * be the enclave's address whenever a player submits a move.
     */
    function getSigner(
        uint256 hUFrom,
        uint256 hUTo,
        Signature memory sig
    ) public pure returns (address) {
        bytes32 hash = keccak256(abi.encode(sig.b, hUFrom, hUTo));
        bytes32 prefixedHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
        );
        return ecrecover(prefixedHash, sig.v, sig.r, sig.s);
    }

    function toArray(
        MoveInputs memory moveInputs
    ) internal pure returns (uint256[17] memory) {
        return [
            moveInputs.currentWaterInterval,
            moveInputs.fromPkHash,
            moveInputs.fromCityId,
            moveInputs.toCityId,
            moveInputs.ontoSelfOrUnowned,
            moveInputs.numTroopsMoved,
            moveInputs.enemyLoss,
            moveInputs.fromIsCityTile,
            moveInputs.toIsCityTile,
            moveInputs.takingCity,
            moveInputs.takingCapital,
            moveInputs.fromCityTroops,
            moveInputs.toCityTroops,
            moveInputs.hTFrom,
            moveInputs.hTTo,
            moveInputs.hUFrom,
            moveInputs.hUTo
        ];
    }
}
